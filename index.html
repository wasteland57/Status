<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Status Board</title>
  <style>
    /* Your existing styles remain the same */
  </style>
</head>
<body>
  <h1>Status Board</h1>
  <div id="lastUpdated"></div>
  <div id="statusMessage" class="loading">Loading statuses...</div>
  <div id="board"></div>

  <script>
    // REPLACE THIS WITH YOUR NEW DEPLOYMENT URL
    const SCRIPT_URL = "https://script.google.com/macros/s/AKfycbx19hSE33nEeL7qrxXCkX65IxcUg_3DEdjTltxYGy-U7k3J6P7Yz3u6Ao_8yUDTryyv/exec";
    
    const people = [
      "Brendan Varga", "Doug Kennedy", "Gerrit Cramer", "Isaac Miller", "John Stebelton",
      "Joe Beattie", "Kayla Plancon", "Kyle Buchner", "Kyle Miller", "Melanie Sobas",
      "Paul Bater", "Renee Kehren", "Rob Mooney", "Scott Sieg", "Steve Rowland", 
      "Will Houser"
    ];

    const statusOptions = [
      { text: "I need work", value: "I need work", class: "orange" },
      { text: "I need help", value: "I need help", class: "red" },
      { text: "I'm good", value: "I'm good", class: "green" },
      { text: "I can do more", value: "I can do more", class: "blue" }
    ];

    const board = document.getElementById("board");
    const statusMessage = document.getElementById("statusMessage");
    const lastUpdated = document.getElementById("lastUpdated");

    // Improved fetch with timeout
    async function safeFetch(url, options = {}, timeout = 10000) {
      const controller = new AbortController();
      const timeoutId = setTimeout(() => controller.abort(), timeout);
      
      try {
        const response = await fetch(url, {
          ...options,
          signal: controller.signal,
          mode: 'no-cors' // Important for CORS
        });
        clearTimeout(timeoutId);
        return response;
      } catch (error) {
        clearTimeout(timeoutId);
        throw error;
      }
    }

    function showMessage(text, type = "loading") {
      statusMessage.textContent = text;
      statusMessage.className = type;
      console[type === "error" ? "error" : "log"](text);
    }

    function updateLastUpdated() {
      lastUpdated.textContent = `Last updated: ${new Date().toLocaleString()}`;
    }

    function createStatusDropdown(name, currentStatus) {
      const container = document.createElement("div");
      container.className = "person";

      const label = document.createElement("label");
      label.textContent = name;

      const select = document.createElement("select");
      select.className = "status";
      select.dataset.name = name;

      statusOptions.forEach(option => {
        const optElement = document.createElement("option");
        optElement.value = option.value;
        optElement.textContent = option.text;
        if (option.class) optElement.classList.add(option.class);
        select.appendChild(optElement);
      });

      select.value = currentStatus || "I'm good";
      updateStatusColor(select);

      select.addEventListener("change", async () => {
        updateStatusColor(select);
        await updateStatus(name, select.value);
      });

      container.appendChild(label);
      container.appendChild(select);
      return container;
    }

    function updateStatusColor(selectElement) {
      statusOptions.forEach(opt => {
        selectElement.classList.remove(opt.class);
      });
      const selectedOption = statusOptions.find(opt => opt.value === selectElement.value);
      if (selectedOption?.class) selectElement.classList.add(selectedOption.class);
    }

    async function loadStatuses() {
      try {
        showMessage("Loading statuses...", "loading");
        const response = await safeFetch(`${SCRIPT_URL}?t=${Date.now()}`);
        
        if (!response.ok) throw new Error(`Server returned ${response.status}`);
        
        const data = await response.json();
        if (data.error) throw new Error(data.message || "Server error");
        
        board.innerHTML = "";
        people.forEach(person => {
          board.appendChild(createStatusDropdown(person, data[person] || "I'm good"));
        });
        
        updateLastUpdated();
        showMessage("Statuses loaded", "success");
        setTimeout(() => showMessage("", ""), 2000);
      } catch (error) {
        showMessage(`Error: ${error.message}`, "error");
        setTimeout(loadStatuses, 5000);
      }
    }

    async function updateStatus(name, status) {
      try {
        showMessage(`Updating ${name}...`, "loading");
        
        const response = await safeFetch(SCRIPT_URL, {
          method: "POST",
          headers: { 
            "Content-Type": "application/json",
            "Accept": "application/json"
          },
          body: JSON.stringify({ name, status })
        });
        
        if (!response.ok) throw new Error(`Server returned ${response.status}`);
        
        const result = await response.json();
        if (result.error) throw new Error(result.message || "Update failed");
        
        updateLastUpdated();
        showMessage(`Updated ${name} to "${status}"`, "success");
        setTimeout(() => showMessage("", ""), 2000);
        
        // Refresh the data after successful update
        setTimeout(loadStatuses, 1000);
      } catch (error) {
        showMessage(`Update failed: ${error.message}`, "error");
        console.error("Update error details:", error);
        
        // Revert to server state
        loadStatuses();
      }
    }

    // Initial load
    loadStatuses();
    
    // Auto-refresh every 20 seconds
    setInterval(loadStatuses, 20000);
  </script>
</body>
</html>